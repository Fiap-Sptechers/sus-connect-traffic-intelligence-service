# Configuração específica para Cloud Run / Google Cloud Platform
# Este profile é ativado automaticamente no Cloud Run via SPRING_PROFILES_ACTIVE=cloud

spring:
  application:
    name: traffic-intelligence-service
  
  data:
    redis:
      # Host e porta vêm de secrets do Cloud Run
      host: ${SPRING_DATA_REDIS_HOST:localhost}
      port: ${SPRING_DATA_REDIS_PORT:6379}
      password: ${SPRING_DATA_REDIS_PASSWORD:}
      timeout: 10000ms  # 10 segundos - necessário para conexão via VPC Connector
      lettuce:
        pool:
          max-active: 8
          max-idle: 8
          min-idle: 0
  
  jackson:
    serialization:
      write-dates-as-timestamps: false
    deserialization:
      fail-on-unknown-properties: false

server:
  port: ${PORT:8080}  # Cloud Run define $PORT automaticamente
  tomcat:
    uri-encoding: UTF-8
    threads:
      max: 200
      min-spare: 10

management:
  endpoints:
    web:
      exposure:
        include: health,info,prometheus,metrics
      base-path: /actuator
  endpoint:
    health:
      # Configurar health check para não bloquear em componentes externos
      show-details: when-authorized
      probes:
        enabled: true
      # Timeout para health checks individuais
      health-probe-timeout: 2s
  health:
    # Health checks configurados
    redis:
      enabled: true  # Reabilitado agora que Redis está configurado
    # Circuit breakers não devem bloquear health check principal
    circuitbreakers:
      enabled: false
  metrics:
    export:
      prometheus:
        enabled: true
  tracing:
    sampling:
      probability: 1.0

logging:
  level:
    root: INFO
    com.fiap.sus.traffic: INFO  # Reduzir logs em produção
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n"

traffic:
  intelligence:
    network-service:
      # URL vem de secret do Cloud Run
      url: ${TRAFFIC_INTELLIGENCE_NETWORK_SERVICE_URL:http://network-service:8080}
      timeout: 180000  # 3 minutos - necessário para processar grandes volumes de unidades
      connect-timeout: 5000
    liveops-service:
      # URL vem de secret do Cloud Run
      url: ${TRAFFIC_INTELLIGENCE_LIVEOPS_SERVICE_URL:http://liveops-service:8081}
      # Chave privada para autenticação JWT (vem de secret do Cloud Run)
      private-key: ${TRAFFIC_LIVEOPS_PRIVATE_KEY:}
      timeout: 2000
      connect-timeout: 1000
    cache:
      ttl-indicadores: 30s
      ttl-unidades: 60s
      ttl-pesos: 300s
      ttl-sugestoes: 300s  # Cache de sugestões - 5 minutos
    algoritmo:
      pesos:
        distancia: 0.3
        tma: 0.4
        ocupacao: 0.2
        especialidade: 0.1
      max-sugestoes: 5
      raio-default-km: 50.0
      raio-minimo-km: 1.0
      raio-maximo-km: 100.0

resilience4j:
  circuitbreaker:
    instances:
      networkService:
        registerHealthIndicator: true
        slidingWindowSize: 10
        minimumNumberOfCalls: 5
        permittedNumberOfCallsInHalfOpenState: 3
        automaticTransitionFromOpenToHalfOpenEnabled: true
        waitDurationInOpenState: 10s
        failureRateThreshold: 50
        eventConsumerBufferSize: 10
        recordExceptions:
          - org.springframework.web.client.HttpServerErrorException
          - org.springframework.web.client.HttpClientErrorException
          - feign.FeignException
          - java.net.ConnectException
          - java.util.concurrent.TimeoutException
          - java.io.IOException
      liveOpsService:
        registerHealthIndicator: true
        slidingWindowSize: 10
        minimumNumberOfCalls: 5
        permittedNumberOfCallsInHalfOpenState: 3
        automaticTransitionFromOpenToHalfOpenEnabled: true
        waitDurationInOpenState: 10s
        failureRateThreshold: 50
        eventConsumerBufferSize: 10
        recordExceptions:
          - org.springframework.web.client.HttpServerErrorException
          - org.springframework.web.client.HttpClientErrorException
          - feign.FeignException
          - java.net.ConnectException
          - java.util.concurrent.TimeoutException
          - java.io.IOException
  retry:
    instances:
      networkService:
        maxAttempts: 3
        waitDuration: 500ms
        enableExponentialBackoff: true
        exponentialBackoffMultiplier: 2
      liveOpsService:
        maxAttempts: 3
        waitDuration: 500ms
        enableExponentialBackoff: true
        exponentialBackoffMultiplier: 2

feign:
  client:
    config:
      default:
        connectTimeout: 5000
        readTimeout: 180000  # 3 minutos - necessário para processar grandes volumes
        loggerLevel: basic
      networkService:
        url: ${traffic.intelligence.network-service.url}
        connectTimeout: 5000
        readTimeout: 180000  # 3 minutos para Network Service
      liveOpsService:
        url: ${traffic.intelligence.liveops-service.url}
        connectTimeout: 5000
        readTimeout: 2000
